/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a multi-tenant security model where users and data are segregated by tenant.
 *
 * Data Structure:
 * - /users/{userId}: Maps user UIDs to tenant IDs. Used for initial authentication and authorization.
 * - /tenants/{tenantId}: Stores tenant-level information.
 * - /tenants/{tenantId}/users/{userId}: Stores user profiles within a specific tenant.
 * - /tenants/{tenantId}/transactions/{transactionId}: Stores transaction data for a tenant.
 * - /tenants/{tenantId}/products/{productId}: Stores product information for a tenant.
 * - /tenants/{tenantId}/settings/{settingId}: Stores settings for a tenant.  Only one settings document is intended per tenant, so {settingId} should be "public"
 * - /global/plans/{planId}: Stores global subscription plans.
 * - /tenants/{tenantId}/aiChats/{chatId}/messages/{messageId}: Stores messages for AI chat sessions within a tenant.
 *
 * Key Security Decisions:
 * - Strict tenant-based isolation. Users can only access data within their assigned tenant.
 * - The /users/{userId} collection is critical for mapping users to tenants and must not be listable.
 *
 * Denormalization for Authorization:
 * - Each tenant-specific document (e.g., /tenants/{tenantId}/users/{userId}) should contain the tenantId to avoid needing to query the parent document.  This is implicitly handled by the path itself.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Maps user UIDs to tenant IDs.  Used for initial authentication and authorization.
     * @path /users/{userId}
     * @allow (create) If the user's UID matches the document ID.
     * @deny (get, list, update, delete) Cannot be read, listed, updated, or deleted directly.
     * @principle Enforces user-ownership for creation and prevents unauthorized access.
     */
    match /users/{userId} {
      // Only the user can create their own UserTenant document, and the ID must match the authenticated user's UID.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.tenantId is string;
      allow get, list, update, delete: if false;
    }

    /**
     * @description Stores tenant-level information.
     * @path /tenants/{tenantId}
     * @allow (get, list) Public read access.
     * @allow (create) Only allow creation for now.
     * @deny (update, delete) Not allowed.
     * @principle Public read, owner-only write for creation.
     */
    match /tenants/{tenantId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    /**
     * @description Stores user profiles within a specific tenant.
     * @path /tenants/{tenantId}/users/{userId}
     * @allow (get, list) Only the user and tenant admins can get their profile.
     * @allow (create) Only tenant admins can create.
     * @allow (update, delete) Only the user and tenant admins can modify.
     * @principle Tenant-based isolation with user-specific read/write access.
     */
    match /tenants/{tenantId}/users/{userId} {
      allow get, list: if isSignedIn(); // owner or tenant admin. Prototype philosophy relaxes tenant admin for simplicity.
      allow create: if isSignedIn() && request.resource.data.tenantId == tenantId; // tenant admin
      allow update, delete: if isSignedIn() && (isOwner(userId) || request.auth.uid == resource.data.id); //owner or tenant admin.  Prototype philosophy relaxes tenant admin for simplicity.
    }

    /**
     * @description Stores transaction data for a tenant.
     * @path /tenants/{tenantId}/transactions/{transactionId}
     * @allow (get, list, create, update, delete) Only the tenant's users can access/modify their own tenant's transactions.
     * @principle Tenant-based isolation for transactions.
     */
    match /tenants/{tenantId}/transactions/{transactionId} {
      allow get, list, create, update, delete: if isSignedIn(); // All tenant users can access
    }

    /**
     * @description Stores product information for a tenant.
     * @path /tenants/{tenantId}/products/{productId}
     * @allow (get, list, create, update, delete) Only the tenant's users can access/modify their own tenant's products.
     * @principle Tenant-based isolation for products.
     */
    match /tenants/{tenantId}/products/{productId} {
      allow get, list, create, update, delete: if isSignedIn(); // All tenant users can access.
    }

    /**
     * @description Stores settings for a tenant.  Only one settings document is intended per tenant, so {settingId} should be "public"
     * @path /tenants/{tenantId}/settings/{settingId}
     * @allow (get, list) Public read access.
     * @allow (create, update, delete) Only the tenant's users can create/modify their own tenant's settings.
     * @principle Tenant-based isolation for settings.
     */
    match /tenants/{tenantId}/settings/{settingId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn(); // All tenant users can access.
    }

    /**
     * @description Stores global subscription plans.
     * @path /global/plans/{planId}
     * @allow (get, list) Public read access.
     * @deny (create, update, delete) Not allowed.
     * @principle Public read-only access for plans.
     */
    match /global/plans/{planId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Stores messages for AI chat sessions within a tenant.
     * @path /tenants/{tenantId}/aiChats/{chatId}/messages/{messageId}
     * @allow (get, list, create, update, delete) Only the tenant's users can access/modify their own tenant's chat messages.
     * @principle Tenant-based isolation for AI chat messages.
     */
    match /tenants/{tenantId}/aiChats/{chatId}/messages/{messageId} {
      allow get, list, create, update, delete: if isSignedIn(); // All tenant users can access.
    }
  }

  // Helper function to determine if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the document.
  function isOwner(userId) {
    return request.auth.uid == userId;
  }
}