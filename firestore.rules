/**
 * @fileoverview Firestore Security Rules for ERP System.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant security model where access is granted based on the user's tenant ID.
 * All data is nested under /tenants/{tenantId}, and access is controlled by verifying that the authenticated
 * user's tenant ID matches the tenant ID in the path. The rules also provides additional security
 * based on collections access patterns, such as Owner access, Public Read with Owner Writes, and
 * Shared Access using resource based custom claims.
 *
 * Data Structure:
 * - /users/{userId}: Maps user UIDs to tenant IDs. This is for simpler authorization.
 * - /tenants/{tenantId}: Contains tenant-specific data.
 * - All other tenant-owned collections are nested under /tenants/{tenantId}/...
 * - /global/plans/{planId}: Contains global plan data.
 * - /mail/{mailId}: Contains data for triggering email sending by the extension.
 *
 * Key Security Decisions:
 * - Tenant Isolation: Strict enforcement of tenant-based access control. Users can only access data
 *   belonging to their assigned tenant.
 * - No User Listing: Listing users is generally disallowed to prevent information leakage.
 * - Flexible Data Validation: Data validation is kept minimal in the prototyping stage, focusing on
 *   authorization and data consistency for relational integrity rather than strict schema enforcement.
 * - Public Read for 'global/plans': Read access is public, but write access is implicitly denied as no authenticated user has write access.
 *
 * Denormalization for Authorization:
 * The /users/{userId} collection denormalizes the tenantId, which is stored at the top level instead of
 * querying the user document within the tenant. This reduces the number of reads required for
 * authorization checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows reading and writing the user's tenant mapping if the user is signed in.
     * @path /users/{userId}
     * @allow (create) Signed-in user creates their tenant mapping.
     * @deny (create) Unauthenticated user attempts to create a tenant mapping.
     * @deny (update) Any user attempts to update the mapping.
     * @deny (delete) Any user attempts to delete the mapping.
     * @principle Enforces identity-based access control.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.tenantId is string;
      allow update, delete: if false;
    }

    /**
     * @description Enforces tenant-based access control for all collections under /tenants/{tenantId}.
     * @path /tenants/{tenantId}/{coll=**}/{doc}
     * @allow (read, write) Authenticated user with a matching tenant ID in their custom token.
     * @deny (read, write) Authenticated user with a mismatched tenant ID.
     * @deny (read, write) Unauthenticated user.
     * @principle Tenant-based access control.
     */
    match /tenants/{tenantId}/{coll=**}/{doc} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isTenantMember(tenantId) {
        return isSignedIn() && request.auth.token.tenantId == tenantId;
      }
      allow get: if isTenantMember(tenantId);
      allow list: if isTenantMember(tenantId);
      allow create: if isTenantMember(tenantId);
      allow update: if isTenantMember(tenantId);
      allow delete: if isTenantMember(tenantId);
    }

    /**
     * @description Allows public read access to subscription plans.
     * @path /global/plans/{planId}
     * @allow (get, list) Any user can read subscription plans.
     * @deny (create, update, delete) No one can write plans through rules (only backend).
     * @principle Public read access with owner-only writes (backend only).
     */
    match /global/plans/{planId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

     /**
      * @description Allows the mail extension to create email trigger documents.
      * @path /mail/{mailId}
      * @allow (create) Extension triggers email sending.
      * @deny (get, list, update, delete) Not accessible from the client.
      * @principle Extension-only access.
      */
    match /mail/{mailId} {
      allow get, list, update, delete: if false;
      allow create: if true;
    }
  }
}