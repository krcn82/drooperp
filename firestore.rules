/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a multi-tenant security model where users and data are segregated by tenant.
 *
 * Data Structure:
 * - /users/{userId}: Maps user UIDs to tenant IDs. Used for initial authorization.
 * - /tenants/{tenantId}: Stores tenant information.
 * - /tenants/{tenantId}/users/{userId}: Stores user information within a tenant.
 * - /tenants/{tenantId}/transactions/{transactionId}: Stores transaction data for a tenant.
 * - /tenants/{tenantId}/products/{productId}: Stores product data for a tenant.
 * - /tenants/{tenantId}/settings/{settingId}: Stores settings for a tenant.
 * - /global/plans/{planId}: Stores globally available subscription plans.
 *
 * Key Security Decisions:
 * - Strict user ownership for /users/{userId} documents.
 * - Tenant-based access control for all tenant subcollections.
 * - Global read access for /global/plans/{planId}.
 *
 * Error Context:
 * - The error indicates a "permission-error" on a write operation to "/databases/(default)/documents/tenants/The Burgero".
 * - The user "QK0MlhfnRObfgKrB3290bD3VRqu1" is authenticated.
 * - The tenant ID being written is "The Burgero", and the user's auth token indicates the user's name is "The Burgero".
 * - **Implication:** The rules likely lack a condition to allow creating a tenant with an ID matching the user's name. This could be a self-provisioning flow for new tenants.
 *
 * Denormalization for Authorization:
 * - The `User` entity SHOULD include a `tenantId` field to simplify tenant-based access control.  This avoids the need for complex queries or `get()` calls to the `/users/{userId}` document.
 *
 * Structural Segregation:
 * - The `/global/plans/{planId}` collection is segregated from tenant-specific data, allowing for public read access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user IDs match, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID and that the resource exists.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user IDs match, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && exists(resource);
    }

    /**
     * @description Allows the owner to manage their UserTenant document.
     * @path /users/{userId}
     * @allow (create) User QK0MlhfnRObfgKrB3290bD3VRqu1 can create /users/QK0MlhfnRObfgKrB3290bD3VRqu1
     * @deny (create) User QK0MlhfnRObfgKrB3290bD3VRqu1 cannot create /users/someOtherUserId
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows creating tenant documents, but ONLY if the tenant ID matches the user's name from their auth token.
     * @path /tenants/{tenantId}
     * @allow (create) User "The Burgero" can create /tenants/The Burgero
     * @deny (create) User "The Burgero" cannot create /tenants/SomeOtherTenantId
     * @principle Enforces that new tenants can only be created using their own name as the ID from their auth token.
     */
    match /tenants/{tenantId} {
       allow get: if true;
       allow list: if false;
       allow create: if request.auth.token.name == tenantId;
       allow update: if false; // TODO: Add logic for admins or tenant owners to update tenant info
       allow delete: if false; // TODO: Add logic for admins or tenant owners to delete tenant info
    }

    /**
     * @description Allows tenant users to manage their user data within a tenant.
     * @path /tenants/{tenantId}/users/{userId}
     * @allow (create) User QK0MlhfnRObfgKrB3290bD3VRqu1 can create /tenants/tenant1/users/QK0MlhfnRObfgKrB3290bD3VRqu1
     * @deny (create) User QK0MlhfnRObfgKrB3290bD3VRqu1 cannot create /tenants/tenant1/users/someOtherUserId
     * @principle Enforces document ownership for writes within a tenant.
     */
    match /tenants/{tenantId}/users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows tenant users to manage transactions within their tenant.
     * @path /tenants/{tenantId}/transactions/{transactionId}
     * @allow (create) User can create a transaction in their tenant
     * @deny (delete) User cannot delete a transaction they don't own
     * @principle Enforces tenant-based access control for transactions.
     */
    match /tenants/{tenantId}/transactions/{transactionId} {
      allow get: if true;
      allow list: if false;
      allow create: if true; // TODO: Add ownership validation and RBAC for create once owner field exist in data shape
      allow update: if false; // TODO: Add ownership validation and RBAC for update once owner field exist in data shape
      allow delete: if false; // TODO: Add ownership validation and RBAC for delete once owner field exist in data shape
    }

    /**
     * @description Allows tenant users to manage products within their tenant.
     * @path /tenants/{tenantId}/products/{productId}
     * @allow (create) User can create a product in their tenant
     * @deny (delete) User cannot delete a product they don't own
     * @principle Enforces tenant-based access control for products.
     */
    match /tenants/{tenantId}/products/{productId} {
      allow get: if true;
      allow list: if false;
      allow create: if true; // TODO: Add ownership validation and RBAC for create once owner field exist in data shape
      allow update: if false; // TODO: Add ownership validation and RBAC for update once owner field exist in data shape
      allow delete: if false; // TODO: Add ownership validation and RBAC for delete once owner field exist in data shape
    }

      /**
       * @description Allows tenant users to manage setting within their tenant.
       * @path /tenants/{tenantId}/settings/{settingId}
       * @allow (create) User can create a setting in their tenant
       * @deny (delete) User cannot delete a setting they don't own
       * @principle Enforces tenant-based access control for settings.
       */
      match /tenants/{tenantId}/settings/{settingId} {
        allow get: if true;
        allow list: if false;
        allow create: if true; // TODO: Add ownership validation and RBAC for create once owner field exist in data shape
        allow update: if false; // TODO: Add ownership validation and RBAC for update once owner field exist in data shape
        allow delete: if false; // TODO: Add ownership validation and RBAC for delete once owner field exist in data shape
      }

    /**
     * @description Allows public read access to subscription plans.
     * @path /global/plans/{planId}
     * @allow (get) Any user can get a plan
     * @deny (create) No one can create a plan
     * @principle Public read access with no write access.
     */
    match /global/plans/{planId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}