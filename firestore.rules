/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant data model with user-based access control.
 * Users can only manage their own data and data within their assigned tenant.
 * Public read access is granted to the `plans` collection.
 *
 * Data Structure:
 * - `/users/{userId}`: Maps user UIDs to tenant IDs. Used for initial auth and security rules.
 * - `/tenants/{tenantId}`: Stores tenant-specific information.
 * - `/tenants/{tenantId}/users/{userId}`: Stores user profiles within a tenant.
 * - `/tenants/{tenantId}/transactions/{transactionId}`: Stores transaction data for a tenant.
 * - `/tenants/{tenantId}/products/{productId}`: Stores product information for a tenant.
 * - `/tenants/{tenantId}/settings/{settingId}`: Stores settings for a tenant.
 * - `/global/plans/{planId}`: Stores global subscription plans. This collection is publicly readable.
 *
 * Key Security Decisions:
 * - Users can only create their own /users/{userId} document.
 * - Users can only read and write data within their assigned tenant.
 * - Listing of users within a tenant is allowed only to authenticated users.
 * - Global plans are publicly readable, but only writeable by a privileged role (not implemented in this prototyping phase).
 *
 * Denormalization for Authorization:
 * - The `UserTenant` entity at `/users/{userId}` denormalizes the `tenantId` to avoid needing to query the `tenants` collection
 *   for basic authorization.
 *
 * Structural Segregation:
 * - Private user data is stored under `/tenants/{tenantId}/users/{userId}`, while the initial auth mapping is stored in `/users/{userId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows a user to create their own UserTenant document, which maps their UID to a tenant ID.
     * @path /users/{userId}
     * @allow (create) - Authenticated user with UID 'user123' can create a document at /users/user123 with matching ID and tenantId.
     * @deny (create) - Authenticated user with UID 'user123' cannot create a document at /users/user456.
     * @principle Enforces self-creation: A user can only create a document where the userId matches their auth UID.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.tenantId is string;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to tenant information.
     * @path /tenants/{tenantId}
     * @allow (get) - Authenticated user can retrieve tenant information.
     * @allow (list) - Authenticated user can list tenants.
     * @deny (create) - No one can create a tenant through client side.
     * @principle Restricts tenant creation and enforces authentication for access.
     */
    match /tenants/{tenantId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages user access within a tenant.
     * @path /tenants/{tenantId}/users/{userId}
     * @allow (get) - Authenticated user can retrieve their own user profile within the tenant.
     * @allow (list) - Authenticated user can list other users in the tenant.
     * @deny (create) - User cannot create a user with different user ID.
     * @principle Enforces user-level access control within a tenant.
     */
    match /tenants/{tenantId}/users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId && request.resource.data.tenantId == tenantId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.id == userId && resource.data.tenantId == tenantId;
      allow delete: if isSignedIn() && isOwner(userId) && resource.data.id == userId && resource.data.tenantId == tenantId;
    }

    /**
     * @description Restricts access to transaction data within a tenant.
     * @path /tenants/{tenantId}/transactions/{transactionId}
     * @allow (get) - Authenticated user can retrieve transaction information.
     * @allow (list) - Authenticated user can list transactions.
     * @deny (create) - User cannot create a transaction with different tenant ID.
     * @principle Enforces tenant-level access control for transactions.
     */
    match /tenants/{tenantId}/transactions/{transactionId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.tenantId == tenantId;
      allow update: if isSignedIn() && resource.data.tenantId == tenantId;
      allow delete: if isSignedIn() && resource.data.tenantId == tenantId;
    }

    /**
     * @description Manages access to product data within a tenant.
     * @path /tenants/{tenantId}/products/{productId}
     * @allow (get) - Authenticated user can retrieve product information.
     * @allow (list) - Authenticated user can list products.
     * @deny (create) - User cannot create a product with different tenant ID.
     * @principle Enforces tenant-level access control for products.
     */
    match /tenants/{tenantId}/products/{productId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.tenantId == tenantId;
      allow update: if isSignedIn() && resource.data.tenantId == tenantId;
      allow delete: if isSignedIn() && resource.data.tenantId == tenantId;
    }

    /**
     * @description Restricts access to settings within a tenant.
     * @path /tenants/{tenantId}/settings/{settingId}
     * @allow (get) - Authenticated user can retrieve settings.
     * @allow (list) - Authenticated user can list settings.
     * @deny (create) - User cannot create a setting with different tenant ID.
     * @principle Enforces tenant-level access control for settings.
     */
    match /tenants/{tenantId}/settings/{settingId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.tenantId == tenantId;
      allow update: if isSignedIn() && resource.data.tenantId == tenantId;
      allow delete: if isSignedIn() && resource.data.tenantId == tenantId;
    }

    /**
     * @description Grants public read access to subscription plans.  Write access should be restricted to privileged roles (not implemented here).
     * @path /global/plans/{planId}
     * @allow (get) - Any user can retrieve a plan.
     * @allow (list) - Any user can list plans.
     * @deny (create) - No one can create a plan, unless a privileged role is checked for.
     * @principle Provides public read access to plans.
     */
    match /global/plans/{planId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}