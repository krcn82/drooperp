/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant security model. Users are associated with tenants,
 * and data access is generally restricted to users within their respective tenants.
 *
 * Data Structure:
 * - /users/{userId}: Maps user UIDs to tenant IDs.  This top-level collection is readable only by the user themselves.
 * - /tenants/{tenantId}: Stores tenant information.
 * - /tenants/{tenantId}/users/{userId}: Stores user profiles within a tenant.
 * - /tenants/{tenantId}/transactions/{transactionId}: Stores transaction data for a tenant.
 * - /tenants/{tenantId}/products/{productId}: Stores product data for a tenant.
 * - /tenants/{tenantId}/settings/{settingId}: Stores settings data for a tenant.
 * - /global/plans/{planId}: Stores global subscription plans (publicly readable).
 *
 * Key Security Decisions:
 * - User-owned data: The /users/{userId} collection enforces strict ownership.
 * - Tenant-based access: Most data is namespaced under a tenant ID, and access is restricted to users within that tenant.
 * - Global plans: The /global/plans collection is publicly readable, but only writeable by a hypothetical admin (not implemented).
 * - No user listing: Listing all users in any collection is disallowed.
 *
 * Denormalization for Authorization:
 * - The `tenantId` is denormalized onto all tenant-specific documents (users, transactions, products) to simplify security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects the top-level /users/{userId} collection, mapping user IDs to tenant IDs.
     * @path /users/{userId}
     * @allow (create) - If the user's auth UID matches the userId. The tenantId must also be set in the document.
     * @allow (get, list, update, delete) - If the user's auth UID matches the userId.
     * @deny (create) - If the user's auth UID does not match the userId, or if the tenantId is missing.
     * @deny (get, list, update, delete) - If the user's auth UID does not match the userId.
     * @principle Enforces document ownership and validates relational integrity.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.tenantId is string;
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Protects the /tenants/{tenantId} collection, storing tenant information.
     * @path /tenants/{tenantId}
     * @allow (get, list) - if false
     * @allow (create, update, delete) - if false
     * @deny (get, list) - Always deny. Listing/getting tenants is not allowed.
     * @deny (create, update, delete) - Always deny. Creating/modifying tenants is not allowed.
     * @principle Enforces tenant-level access control.
     */
    match /tenants/{tenantId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Protects the /tenants/{tenantId}/users/{userId} subcollection, storing user profiles within a tenant.
     * @path /tenants/{tenantId}/users/{userId}
     * @allow (get) - If the user's auth UID matches the userId AND the user belongs to the tenant.
     * @allow (list) - If the user belongs to the tenant
     * @allow (create) - If the user's auth UID matches the userId AND the tenantId in the document matches the path.
     * @allow (update) - If the user's auth UID matches the userId AND the user belongs to the tenant.
     * @allow (delete) - If the user's auth UID matches the userId AND the user belongs to the tenant.
     * @deny (get, create, update, delete) - If the user's auth UID does not match the userId, or if the tenantId is mismatched.
     * @principle Enforces tenant-level access control and validates relational integrity.
     */
    match /tenants/{tenantId}/users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function belongsToTenant(tenantId) {
          return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
      }

      allow get: if isSignedIn() && isOwner(userId) && belongsToTenant(tenantId);
      allow list: if isSignedIn() && belongsToTenant(tenantId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.tenantId == tenantId;
      allow update: if isSignedIn() && isOwner(userId) && belongsToTenant(tenantId);
      allow delete: if isSignedIn() && isOwner(userId) && belongsToTenant(tenantId);
    }

    /**
     * @description Protects the /tenants/{tenantId}/transactions/{transactionId} subcollection, storing transaction data.
     * @path /tenants/{tenantId}/transactions/{transactionId}
     * @allow (get, list) - If the user belongs to the tenant.
     * @allow (create) - If the tenantId in the document matches the path.
     * @allow (update, delete) - If the user belongs to the tenant AND the document exists.
     * @deny (create, update, delete) - If the tenantId is mismatched or the user does not belong to the tenant.
     * @principle Enforces tenant-level access control and validates relational integrity.
     */
    match /tenants/{tenantId}/transactions/{transactionId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function belongsToTenant(tenantId) {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
      }

      allow get: if isSignedIn() && belongsToTenant(tenantId);
      allow list: if isSignedIn() && belongsToTenant(tenantId);
      allow create: if isSignedIn() && request.resource.data.tenantId == tenantId;
      allow update: if isSignedIn() && belongsToTenant(tenantId) && resource != null;
      allow delete: if isSignedIn() && belongsToTenant(tenantId) && resource != null;
    }

    /**
     * @description Protects the /tenants/{tenantId}/products/{productId} subcollection, storing product data.
     * @path /tenants/{tenantId}/products/{productId}
     * @allow (get, list) - If the user belongs to the tenant.
     * @allow (create) - If the tenantId in the document matches the path.
     * @allow (update, delete) - If the user belongs to the tenant AND the document exists.
     * @deny (create, update, delete) - If the tenantId is mismatched or the user does not belong to the tenant.
     * @principle Enforces tenant-level access control and validates relational integrity.
     */
    match /tenants/{tenantId}/products/{productId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function belongsToTenant(tenantId) {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
      }

      allow get: if isSignedIn() && belongsToTenant(tenantId);
      allow list: if isSignedIn() && belongsToTenant(tenantId);
      allow create: if isSignedIn() && request.resource.data.tenantId == tenantId;
      allow update: if isSignedIn() && belongsToTenant(tenantId) && resource != null;
      allow delete: if isSignedIn() && belongsToTenant(tenantId) && resource != null;
    }

      /**
       * @description Protects the /tenants/{tenantId}/settings/{settingId} subcollection, storing tenant settings data.
       * @path /tenants/{tenantId}/settings/{settingId}
       * @allow (get, list) - If the user belongs to the tenant.
       * @allow (create) - If the tenantId in the document matches the path.
       * @allow (update, delete) - If the user belongs to the tenant AND the document exists.
       * @deny (create, update, delete) - If the tenantId is mismatched or the user does not belong to the tenant.
       * @principle Enforces tenant-level access control and validates relational integrity.
       */
      match /tenants/{tenantId}/settings/{settingId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function belongsToTenant(tenantId) {
            return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
        }

        allow get: if isSignedIn() && belongsToTenant(tenantId);
        allow list: if isSignedIn() && belongsToTenant(tenantId);
        allow create: if isSignedIn() && request.resource.data.tenantId == tenantId;
        allow update: if isSignedIn() && belongsToTenant(tenantId) && resource != null;
        allow delete: if isSignedIn() && belongsToTenant(tenantId) && resource != null;
      }


    /**
     * @description Protects the /global/plans/{planId} collection, storing global subscription plans.
     * @path /global/plans/{planId}
     * @allow (get, list) - Public read access.
     * @allow (create, update, delete) - Denied.  Write access would typically be limited to an admin role.
     * @deny (create, update, delete) - Always deny. Only admins are allowed.
     * @principle Allows public read access and restricts write access.
     */
    match /global/plans/{planId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}