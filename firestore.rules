/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for most data, ensuring that users can only access data related to their tenant.
 *
 * Data Structure:
 * - /users/{userId}: Maps user IDs to tenant IDs. This is the primary entry point for determining a user's tenant.
 * - /tenants/{tenantId}: Stores tenant-specific data.
 * - /tenants/{tenantId}/[...]: Subcollections under tenants store tenant-specific data, such as users, transactions, products, and settings.
 * - /global/plans/{planId}: Stores global subscription plans. This collection is publicly readable.
 *
 * Key Security Decisions:
 * - User Listing is disallowed.
 * - Global subscription plans are publicly readable.
 * - Default security posture for ambiguous relationships is strict owner-only access.
 *
 * Denormalization for Authorization:
 *  The /users/{userId} document maps the user's UID to their tenantId. This denormalization is critical for efficiently authorizing access to tenant-specific data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Authentication is required for all protected resources.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource based on the provided userId.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces user-based ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource and the resource exists.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Combines ownership and existence checks for safer destructive operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Gets the tenant ID associated with a user.
     * @path N/A
     */
    function getTenantIdForUser(userId) {
        return get(/databases/$(database)/documents/users/$(userId)).data.tenantId;
    }

   /**
     * @description Checks if the authenticated user belongs to the tenant.
     * @path N/A
     */
    function belongsToTenant(tenantId) {
      return isSignedIn() && getTenantIdForUser(request.auth.uid) == tenantId;
    }

    /**
     * @description Top-level collection to map user UIDs to tenant IDs for security rules.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' creates a document with id 'user123'.
     * @deny (create) User with UID 'user123' attempts to create a document with id 'user456'.
     * @principle Enforces that users can only create their own user-tenant mapping.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.tenantId is string;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Collection to store tenant information.
     * @path /tenants/{tenantId}
     * @allow (get) Any authenticated user can read tenant information if they belong to the tenant.
     * @deny (create) Any user attempts to create a tenant without proper authorization.
     * @principle Limits access to tenant data to authorized users.
     */
    match /tenants/{tenantId} {
      allow get: if belongsToTenant(tenantId);
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Sub-collection for users within a tenant.
     * @path /tenants/{tenantId}/users/{userId}
     * @allow (create) User with UID 'user123' creates a user document in tenant 'tenant123' if they belong to that tenant.
     * @deny (update) User attempts to update a user document in a tenant they don't belong to.
     * @principle Enforces that only users belonging to a tenant can create/modify user documents within that tenant.
     */
    match /tenants/{tenantId}/users/{userId} {
      allow get: if belongsToTenant(tenantId);
      allow list: if false;
      allow create: if belongsToTenant(tenantId);
      allow update: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }

    /**
     * @description Sub-collection for transactions within a tenant.
     * @path /tenants/{tenantId}/transactions/{transactionId}
     * @allow (get) User can read a transaction if they belong to the tenant.
     * @deny (create) User attempts to create a transaction in a tenant they don't belong to.
     * @principle Enforces that only users belonging to a tenant can manage transactions within that tenant.
     */
    match /tenants/{tenantId}/transactions/{transactionId} {
      allow get: if belongsToTenant(tenantId);
      allow list: if belongsToTenant(tenantId);
      allow create: if belongsToTenant(tenantId);
      allow update: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }

    /**
     * @description Sub-collection for products within a tenant.
     * @path /tenants/{tenantId}/products/{productId}
     * @allow (get) User can read a product if they belong to the tenant.
     * @deny (update) User attempts to update a product in a tenant they don't belong to.
     * @principle Enforces that only users belonging to a tenant can manage products within that tenant.
     */
    match /tenants/{tenantId}/products/{productId} {
      allow get: if belongsToTenant(tenantId);
      allow list: if belongsToTenant(tenantId);
      allow create: if belongsToTenant(tenantId);
      allow update: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }

    /**
     * @description Document for general settings within a tenant.
     * @path /tenants/{tenantId}/settings/general
     * @allow (get) User can read settings if they belong to the tenant.
     * @deny (update) User attempts to update settings in a tenant they don't belong to.
     * @principle Enforces that only users belonging to a tenant can manage settings within that tenant.
     */
    match /tenants/{tenantId}/settings/general {
      allow get: if belongsToTenant(tenantId);
      allow list: if false;
      allow create: if belongsToTenant(tenantId);
      allow update: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }

    /**
     * @description Document for module settings within a tenant.
     * @path /tenants/{tenantId}/settings/modules
     * @allow (get) User can read module settings if they belong to the tenant.
     * @deny (update) User attempts to update module settings in a tenant they don't belong to.
     * @principle Enforces that only users belonging to a tenant can manage module settings within that tenant.
     */
    match /tenants/{tenantId}/settings/modules {
      allow get: if belongsToTenant(tenantId);
      allow list: if false;
      allow create: if belongsToTenant(tenantId);
      allow update: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }

    /**
     * @description Document for RKSV key and status within a tenant.
     * @path /tenants/{tenantId}/settings/rksv
     * @allow (get) User can read RKSV settings if they belong to the tenant.
     * @deny (update) User attempts to update RKSV settings in a tenant they don't belong to.
     * @principle Enforces that only users belonging to a tenant can manage RKSV settings within that tenant.
     */
    match /tenants/{tenantId}/settings/rksv {
      allow get: if belongsToTenant(tenantId);
      allow list: if false;
      allow create: if belongsToTenant(tenantId);
      allow update: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }

    /**
     * @description Stores credentials and status for third-party integrations like Wolt or Foodora.
     * @path /tenants/{tenantId}/integrations/{platformId}
     * @allow (get) User can read integration settings if they belong to the tenant.
     * @deny (update) User attempts to update integration settings in a tenant they don't belong to.
     * @principle Enforces that only users belonging to a tenant can manage integrations within that tenant.
     */
    match /tenants/{tenantId}/integrations/{platformId} {
      allow get: if belongsToTenant(tenantId);
      allow list: if false;
      allow create: if belongsToTenant(tenantId);
      allow update: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }

    /**
     * @description Global collection for subscription plans.
     * @path /global/plans/{planId}
     * @allow (get) Any user can read subscription plans.
     * @deny (create) Any user attempts to create a subscription plan without proper authorization.
     * @principle Makes subscription plans publicly readable.
     */
    match /global/plans/{planId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Sub-collection for messages within an AI chat session.
     * @path /tenants/{tenantId}/aiChats/{chatId}/messages/{messageId}
     * @allow (get) User can read a chat message if they belong to the tenant.
     * @deny (create) User attempts to create a chat message in a tenant they don't belong to.
     * @principle Enforces that only users belonging to a tenant can manage chat messages within that tenant.
     */
    match /tenants/{tenantId}/aiChats/{chatId}/messages/{messageId} {
      allow get: if belongsToTenant(tenantId);
      allow list: if belongsToTenant(tenantId);
      allow create: if belongsToTenant(tenantId);
      allow update: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }

    /**
     * @description Sub-collection for orders from external POS/delivery platforms.
     * @path /tenants/{tenantId}/posOrders/{orderId}
     * @allow (get) User can read a POS order if they belong to the tenant.
     * @deny (create) User attempts to create a POS order in a tenant they don't belong to.
     * @principle Enforces that only users belonging to a tenant can manage POS orders within that tenant.
     */
    match /tenants/{tenantId}/posOrders/{orderId} {
      allow get: if belongsToTenant(tenantId);
      allow list: if belongsToTenant(tenantId);
      allow create: if belongsToTenant(tenantId);
      allow update: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }

        /**
         * @description Sub-collection for logging incoming webhook API calls.
         * @path /tenants/{tenantId}/auditLogs/{logId}
         * @allow (get) User can read an audit log if they belong to the tenant.
         * @deny (create) User attempts to create an audit log in a tenant they don't belong to.
         * @principle Enforces that only users belonging to a tenant can manage audit logs within that tenant.
         */
        match /tenants/{tenantId}/auditLogs/{logId} {
          allow get: if belongsToTenant(tenantId);
          allow list: if belongsToTenant(tenantId);
          allow create: if belongsToTenant(tenantId);
          allow update: if belongsToTenant(tenantId);
          allow delete: if belongsToTenant(tenantId);
        }
  }
}